{"ast":null,"code":"/* eslint-disable max-len */\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nimport { updateItem, resolveItemsIds } from './utils/itemUtils';\nimport { EXPAND_FIELD, SELECT_FIELD, CHECK_FIELD, CHECK_INDETERMINATE_FIELD, CHILDREN_FIELD } from './utils/consts';\nimport { getNestedValue, isArray } from './utils/misc';\n/**\n * A helper function which applies the specified operation descriptors to the data.\n * * [Expanding and collapsing items]({% slug expansion_ways_treeview %}#toc-using-a-helper-function)\n * * [Selecting and deselecting items]({% slug selection_ways_treeview %}#toc-using-a-helper-function)\n * * [Checking and unchecking items]({% slug check_helper_funcs_treeview %})\n *\n * @param data - The data that will be processed.\n * @param operations - The operation descriptors that will be applied to the data.\n * @returns - The processed copy of the input data.\n *\n * @example\n * ```jsx\n * class App extends React.Component {\n *     state = { items: tree, expand: [], select: [], check: [] };\n *     render() {\n *         const { expand, select, check } = this.state;\n *         return (\n *             <TreeView\n *                 data={processTreeViewItems(this.state.items, { expand, select, check })}\n *                 expandIcons={true} onExpandChange={this.onExpandChange} checkboxes={true}\n *                 onCheckChange={event => this.setState({ check: [ event.itemHierarchicalIndex ] })}\n *                 onItemClick={event => this.setState({ select: [ event.itemHierarchicalIndex ] })}\n *             />\n *         );\n *     }\n *     onExpandChange = (event) => {\n *         let expand = this.state.expand.slice();\n *         const index = expand.indexOf(event.itemHierarchicalIndex);\n *         index === -1 ? expand.push(event.itemHierarchicalIndex) : expand.splice(index, 1);\n *         this.setState({ expand });\n *     }\n * }\n *\n * const tree = [{\n *     text: 'Item1',\n *     items: [\n *         { text: 'Item1.1' },\n *         { text: 'Item1.2' },\n *         { text: 'Item1.3', items: [{ text: 'Item1.3.1' }] }]\n * }, {\n *     text: 'Item2', disabled: true,\n *     items: [{ text: 'Item2.1' }, { text: 'Item2.2' }, { text: 'Item2.3' }]\n * }, {\n *     text: 'Item3'\n * }];\n *\n * ReactDOM.render(<App />, document.querySelector('my-app'));\n * ```\n */\n\nexport default function processTreeViewItems(data, operations) {\n  if (!data || !data.length) {\n    return [];\n  }\n\n  var result = data;\n  var cloneField = operations.cloneField || 'cloned';\n  var expandField = operations.expandField || EXPAND_FIELD;\n  var selectField = operations.selectField || SELECT_FIELD;\n  var checkField = operations.checkField || CHECK_FIELD;\n  var childrenField = operations.childrenField || CHILDREN_FIELD;\n  result = handleOperation(result, expandField, operations.expand, cloneField, childrenField);\n  result = handleOperation(result, selectField, operations.select, cloneField, childrenField);\n  result = handleOperation(result, checkField, operations.check, cloneField, childrenField);\n  applyCheckIndeterminate(result, childrenField, operations.check);\n  return result;\n}\n\nfunction handleOperation(items, defaultField, operation, cloneField, childrenField) {\n  if (operation) {\n    var _a = parseOperation(operation, defaultField),\n        ids = _a.ids,\n        field = _a.field;\n\n    var indices = !isArray(operation) && operation.idField ? resolveItemsIds(ids, operation.idField, items, childrenField) : ids;\n    return raiseFlags(items, indices, field, cloneField, childrenField);\n  } else {\n    return items;\n  }\n}\n\nfunction parseOperation(operation, defaultField) {\n  var ids;\n  var field;\n\n  if (isArray(operation)) {\n    ids = operation;\n    field = defaultField;\n  } else {\n    ids = operation.ids || [];\n    field = operation.operationField || defaultField;\n  }\n\n  return {\n    ids: ids,\n    field: field\n  };\n}\n\nfunction raiseFlags(items, indices, field, cloneField, childrenField) {\n  var result = items;\n  indices.forEach(function (itemIndex) {\n    result = updateItem(result, itemIndex, function (item) {\n      return raiseNestedFlag(field, item);\n    }, cloneField, childrenField);\n  });\n  return result;\n}\n\nfunction raiseNestedFlag(fieldName, dataItem) {\n  var fields = (fieldName || '').split('.');\n  var item = dataItem;\n\n  for (var index = 0; index < fields.length; index++) {\n    var field = fields[index];\n\n    if (index === fields.length - 1) {\n      item[field] = true;\n    } else if (item[field] !== undefined) {\n      item[field] = __assign({}, item[field]);\n      item = item[field];\n    } else {\n      return;\n    }\n  }\n}\n\nfunction applyCheckIndeterminate(items, childrenField, check) {\n  if (check && !isArray(check) && check.applyCheckIndeterminate) {\n    var checkField = parseOperation(check, CHECK_FIELD).field;\n    var checkIndeterminateField = check.checkIndeterminateField || CHECK_INDETERMINATE_FIELD;\n\n    for (var i = 0; i < items.length; i++) {\n      var item = items[i];\n      var subItems = item[childrenField];\n\n      if (subItems) {\n        applyCheckIndeterminateHelper(subItems, getNestedValue(checkField, item) ? [] : [item], childrenField, checkField, checkIndeterminateField);\n      }\n    }\n  }\n}\n\nfunction applyCheckIndeterminateHelper(data, parents, childrenField, checkField, checkIndeterminateField) {\n  // The updates will be direct because the corresponding items\n  // are already cloned because of their checked children.\n  var parentsAlreadyUpdated = false;\n\n  for (var i = 0; i < data.length; i++) {\n    var item = data[i];\n\n    if (getNestedValue(checkField, item)) {\n      if (!parentsAlreadyUpdated) {\n        for (var j = 0; j < parents.length; j++) {\n          raiseNestedFlag(checkIndeterminateField, parents[j]);\n        }\n      }\n\n      parentsAlreadyUpdated = true;\n\n      if (item[childrenField]) {\n        applyCheckIndeterminateHelper(item[childrenField], [], childrenField, checkField, checkIndeterminateField);\n      }\n    } else {\n      if (item[childrenField]) {\n        applyCheckIndeterminateHelper(item[childrenField], parentsAlreadyUpdated ? [item] : parents.concat([item]), childrenField, checkField, checkIndeterminateField);\n      }\n    }\n  }\n}","map":{"version":3,"sources":["/Users/leecavazos/Desktop/COSC4353/COSC4353-1/frontend/node_modules/@progress/kendo-react-treeview/dist/es/processTreeViewItems.js"],"names":["__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","updateItem","resolveItemsIds","EXPAND_FIELD","SELECT_FIELD","CHECK_FIELD","CHECK_INDETERMINATE_FIELD","CHILDREN_FIELD","getNestedValue","isArray","processTreeViewItems","data","operations","result","cloneField","expandField","selectField","checkField","childrenField","handleOperation","expand","select","check","applyCheckIndeterminate","items","defaultField","operation","_a","parseOperation","ids","field","indices","idField","raiseFlags","operationField","forEach","itemIndex","item","raiseNestedFlag","fieldName","dataItem","fields","split","index","undefined","checkIndeterminateField","subItems","applyCheckIndeterminateHelper","parents","parentsAlreadyUpdated","j","concat"],"mappings":"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","sourcesContent":["/* eslint-disable max-len */\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport { updateItem, resolveItemsIds } from './utils/itemUtils';\nimport { EXPAND_FIELD, SELECT_FIELD, CHECK_FIELD, CHECK_INDETERMINATE_FIELD, CHILDREN_FIELD } from './utils/consts';\nimport { getNestedValue, isArray } from './utils/misc';\n/**\n * A helper function which applies the specified operation descriptors to the data.\n * * [Expanding and collapsing items]({% slug expansion_ways_treeview %}#toc-using-a-helper-function)\n * * [Selecting and deselecting items]({% slug selection_ways_treeview %}#toc-using-a-helper-function)\n * * [Checking and unchecking items]({% slug check_helper_funcs_treeview %})\n *\n * @param data - The data that will be processed.\n * @param operations - The operation descriptors that will be applied to the data.\n * @returns - The processed copy of the input data.\n *\n * @example\n * ```jsx\n * class App extends React.Component {\n *     state = { items: tree, expand: [], select: [], check: [] };\n *     render() {\n *         const { expand, select, check } = this.state;\n *         return (\n *             <TreeView\n *                 data={processTreeViewItems(this.state.items, { expand, select, check })}\n *                 expandIcons={true} onExpandChange={this.onExpandChange} checkboxes={true}\n *                 onCheckChange={event => this.setState({ check: [ event.itemHierarchicalIndex ] })}\n *                 onItemClick={event => this.setState({ select: [ event.itemHierarchicalIndex ] })}\n *             />\n *         );\n *     }\n *     onExpandChange = (event) => {\n *         let expand = this.state.expand.slice();\n *         const index = expand.indexOf(event.itemHierarchicalIndex);\n *         index === -1 ? expand.push(event.itemHierarchicalIndex) : expand.splice(index, 1);\n *         this.setState({ expand });\n *     }\n * }\n *\n * const tree = [{\n *     text: 'Item1',\n *     items: [\n *         { text: 'Item1.1' },\n *         { text: 'Item1.2' },\n *         { text: 'Item1.3', items: [{ text: 'Item1.3.1' }] }]\n * }, {\n *     text: 'Item2', disabled: true,\n *     items: [{ text: 'Item2.1' }, { text: 'Item2.2' }, { text: 'Item2.3' }]\n * }, {\n *     text: 'Item3'\n * }];\n *\n * ReactDOM.render(<App />, document.querySelector('my-app'));\n * ```\n */\nexport default function processTreeViewItems(data, operations) {\n    if (!data || !data.length) {\n        return [];\n    }\n    var result = data;\n    var cloneField = operations.cloneField || 'cloned';\n    var expandField = operations.expandField || EXPAND_FIELD;\n    var selectField = operations.selectField || SELECT_FIELD;\n    var checkField = operations.checkField || CHECK_FIELD;\n    var childrenField = operations.childrenField || CHILDREN_FIELD;\n    result = handleOperation(result, expandField, operations.expand, cloneField, childrenField);\n    result = handleOperation(result, selectField, operations.select, cloneField, childrenField);\n    result = handleOperation(result, checkField, operations.check, cloneField, childrenField);\n    applyCheckIndeterminate(result, childrenField, operations.check);\n    return result;\n}\nfunction handleOperation(items, defaultField, operation, cloneField, childrenField) {\n    if (operation) {\n        var _a = parseOperation(operation, defaultField), ids = _a.ids, field = _a.field;\n        var indices = !isArray(operation) && operation.idField ? resolveItemsIds(ids, operation.idField, items, childrenField) : ids;\n        return raiseFlags(items, indices, field, cloneField, childrenField);\n    }\n    else {\n        return items;\n    }\n}\nfunction parseOperation(operation, defaultField) {\n    var ids;\n    var field;\n    if (isArray(operation)) {\n        ids = operation;\n        field = defaultField;\n    }\n    else {\n        ids = operation.ids || [];\n        field = operation.operationField || defaultField;\n    }\n    return { ids: ids, field: field };\n}\nfunction raiseFlags(items, indices, field, cloneField, childrenField) {\n    var result = items;\n    indices.forEach(function (itemIndex) {\n        result = updateItem(result, itemIndex, function (item) { return raiseNestedFlag(field, item); }, cloneField, childrenField);\n    });\n    return result;\n}\nfunction raiseNestedFlag(fieldName, dataItem) {\n    var fields = (fieldName || '').split('.');\n    var item = dataItem;\n    for (var index = 0; index < fields.length; index++) {\n        var field = fields[index];\n        if (index === fields.length - 1) {\n            item[field] = true;\n        }\n        else if (item[field] !== undefined) {\n            item[field] = __assign({}, item[field]);\n            item = item[field];\n        }\n        else {\n            return;\n        }\n    }\n}\nfunction applyCheckIndeterminate(items, childrenField, check) {\n    if (check && !isArray(check) && check.applyCheckIndeterminate) {\n        var checkField = parseOperation(check, CHECK_FIELD).field;\n        var checkIndeterminateField = check.checkIndeterminateField || CHECK_INDETERMINATE_FIELD;\n        for (var i = 0; i < items.length; i++) {\n            var item = items[i];\n            var subItems = item[childrenField];\n            if (subItems) {\n                applyCheckIndeterminateHelper(subItems, getNestedValue(checkField, item) ? [] : [item], childrenField, checkField, checkIndeterminateField);\n            }\n        }\n    }\n}\nfunction applyCheckIndeterminateHelper(data, parents, childrenField, checkField, checkIndeterminateField) {\n    // The updates will be direct because the corresponding items\n    // are already cloned because of their checked children.\n    var parentsAlreadyUpdated = false;\n    for (var i = 0; i < data.length; i++) {\n        var item = data[i];\n        if (getNestedValue(checkField, item)) {\n            if (!parentsAlreadyUpdated) {\n                for (var j = 0; j < parents.length; j++) {\n                    raiseNestedFlag(checkIndeterminateField, parents[j]);\n                }\n            }\n            parentsAlreadyUpdated = true;\n            if (item[childrenField]) {\n                applyCheckIndeterminateHelper(item[childrenField], [], childrenField, checkField, checkIndeterminateField);\n            }\n        }\n        else {\n            if (item[childrenField]) {\n                applyCheckIndeterminateHelper(item[childrenField], parentsAlreadyUpdated ? [item] : parents.concat([item]), childrenField, checkField, checkIndeterminateField);\n            }\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}