{"ast":null,"code":"import { getter } from '@progress/kendo-react-common';\n/** @hidden */\n\nexport var getValueMap = function (value, idGetter) {\n  var map = {};\n\n  if (value && value.length) {\n    value.forEach(function (item) {\n      map[idGetter(item)] = true;\n    });\n  }\n\n  return map;\n};\n/**\n * Get MultiSelectTree new value from the component `onChange` event.\n *\n * @param {any[]} data\n * @param {object} options\n * @returns {any[]}\n */\n\nexport var getMultiSelectTreeValue = function (data, options) {\n  var items = options.items,\n      dataItemKey = options.dataItemKey,\n      value = options.value,\n      _a = options.subItemsField,\n      subItemsField = _a === void 0 ? 'items' : _a,\n      operation = options.operation;\n  var idGetter = getter(dataItemKey);\n  var valueMap = getValueMap(value, idGetter);\n\n  if (operation === 'clear') {\n    return [];\n  } else if (operation === 'delete') {\n    var deletedItemsMap_1 = getValueMap(items, idGetter);\n    return value.filter(function (item) {\n      return !deletedItemsMap_1[idGetter(item)];\n    });\n  } // operation === 'toggle'\n\n\n  var selectedItem = items[0];\n  var selectedId = idGetter(selectedItem);\n  var subItemGetter = getter(subItemsField);\n  var stack = data.slice();\n  var context = [];\n  var parents;\n  var foundItem;\n\n  while (stack.length) {\n    var currentItem = stack.pop();\n\n    if (selectedId === idGetter(currentItem)) {\n      parents = context.map(function (contextItem) {\n        return contextItem.item;\n      });\n      foundItem = currentItem;\n      break;\n    } else {\n      if (context && context.length && context[context.length - 1].parentPosition === stack.length) {\n        context.pop();\n      }\n\n      var subItems = subItemGetter(currentItem);\n\n      if (subItems && subItems.length) {\n        context.push({\n          item: currentItem,\n          parentPosition: stack.length\n        });\n        stack.push.apply(stack, subItems);\n      }\n    }\n  }\n\n  var childrenStack = (subItemGetter(foundItem) || []).slice();\n  var children = [];\n\n  while (childrenStack.length) {\n    var currentItem = childrenStack.pop();\n    children.push(currentItem);\n    var subItems = subItemGetter(currentItem);\n\n    if (subItems && subItems.length) {\n      childrenStack.push.apply(childrenStack, subItems);\n    }\n  }\n\n  var isChecked = !valueMap[selectedId];\n  var newValue = [];\n\n  if (isChecked) {\n    newValue.push.apply(newValue, value);\n    newValue.push(foundItem);\n    newValue.push.apply(newValue, children.filter(function (item) {\n      return !valueMap[idGetter(item)];\n    }));\n    var parentCandidates = parents.filter(function (item) {\n      return !valueMap[idGetter(item)];\n    });\n    var newValueMap_1 = getValueMap(newValue, idGetter);\n\n    for (var i = parentCandidates.length - 1; i > -1; i--) {\n      var candidate = parentCandidates[i];\n      var subItems = subItemGetter(candidate);\n      var checkedChildrenLength = subItems.filter(function (item) {\n        return newValueMap_1[idGetter(item)];\n      }).length;\n\n      if (checkedChildrenLength < subItems.length) {\n        break;\n      } else {\n        newValue.push(candidate);\n        newValueMap_1[idGetter(candidate)] = true;\n      }\n    }\n  } else {\n    var foundId_1 = idGetter(foundItem);\n    var childrenMap_1 = getValueMap(children, idGetter);\n    var parentsMap_1 = getValueMap(parents, idGetter);\n    newValue.push.apply(newValue, value.filter(function (item) {\n      var itemId = idGetter(item);\n      return !childrenMap_1[itemId] && foundId_1 !== itemId && !parentsMap_1[itemId];\n    }));\n  }\n\n  return newValue;\n}; // /** @hidden */\n// const mapCheckAndIntermidiate = (\n//     data,\n//     options: {\n//         valueMap: {[dataItemKey: string]: boolean};\n//         callback?: (item: any) => any;\n//         idGetter: (item: any) => any;\n//         subItemGetter: (item: any) => any;\n//         subItemSetter: (item: any, value: any) => void;\n//         checkSetter: (item: any, value: any) => void;\n//         checkIndeterminateSetter: (item: any, value: any) => void;\n//     }\n// ) => {\n//     const {\n//         idGetter,\n//         subItemGetter,\n//         subItemSetter,\n//         checkSetter,\n//         checkIndeterminateSetter\n//     } = options;\n//     if (!data || !data.length) { return [data, false];}\n//     let hasChecked = false;\n//     const newData = [...data].map(dataItem => {\n//         const [children, hasCheckedChildren] = mapCheckAndIntermidiate(subItemGetter(dataItem), options);\n//         const isChecked = options.valueMap[idGetter(dataItem)];\n//         if (isChecked || hasCheckedChildren) {\n//             hasChecked = true;\n//         }\n//         const newItem = { ...dataItem };\n//         subItemSetter(newItem, children);\n//         checkSetter(newItem, isChecked);\n//         checkIndeterminateSetter(newItem, !isChecked && hasCheckedChildren);\n//         return options.callback ? options.callback(newItem) : newItem;\n//     });\n//     return [newData, hasChecked];\n// };\n// /**\n//  *\n//  * @param data\n//  * @param options\n//  * @returns\n//  */\n// /**\n//  * Creates a new array with the results of calling the provided callback function\n//  * on every element in the provided data tree. The new tree items have their `check` and `checkIndeterminate` fields set based on provided value.\n//  *\n//  * @param {any[]} tree - The data tree.\n//  * @param {object} options - The options used to map the tree items like check and checkIndeterminateField fields\n//  * @returns {any[]} - The new data tree.\n//  */\n// export const mapMultiSelectTreeData = (\n//     tree,\n//     options: {\n//         checkField?: string;\n//         checkIndeterminateField?: string;\n//         subItemsField?: string;\n//         dataItemKey: string;\n//         value: Array<any>;\n//         callback?: (item) => any;\n//     }\n// ) => {\n//     const {\n//         subItemsField = 'items',\n//         checkField = 'checkField',\n//         checkIndeterminateField = 'checkIndeterminateField',\n//         callback\n//     } = options;\n//     const idGetter = getter(options.dataItemKey);\n//     const [result] = mapCheckAndIntermidiate(\n//         tree,\n//         {\n//             callback,\n//             valueMap: getValueMap(options.value, idGetter),\n//             idGetter,\n//             subItemGetter: getter(subItemsField),\n//             subItemSetter: setter(subItemsField),\n//             checkSetter: setter(checkField),\n//             checkIndeterminateSetter: setter(checkIndeterminateField)\n//         }\n//     );\n//     return result;\n// };","map":{"version":3,"sources":["/Users/leecavazos/Desktop/COSC4353/COSC4353-1/frontend/node_modules/@progress/kendo-react-dropdowns/dist/es/MultiSelectTree/utils.js"],"names":["getter","getValueMap","value","idGetter","map","length","forEach","item","getMultiSelectTreeValue","data","options","items","dataItemKey","_a","subItemsField","operation","valueMap","deletedItemsMap_1","filter","selectedItem","selectedId","subItemGetter","stack","slice","context","parents","foundItem","currentItem","pop","contextItem","parentPosition","subItems","push","apply","childrenStack","children","isChecked","newValue","parentCandidates","newValueMap_1","i","candidate","checkedChildrenLength","foundId_1","childrenMap_1","parentsMap_1","itemId"],"mappings":"AAAA,SAASA,MAAT,QAAuB,8BAAvB;AACA;;AACA,OAAO,IAAIC,WAAW,GAAG,UAAUC,KAAV,EAAiBC,QAAjB,EAA2B;AAChD,MAAIC,GAAG,GAAG,EAAV;;AACA,MAAIF,KAAK,IAAIA,KAAK,CAACG,MAAnB,EAA2B;AACvBH,IAAAA,KAAK,CAACI,OAAN,CAAc,UAAUC,IAAV,EAAgB;AAC1BH,MAAAA,GAAG,CAACD,QAAQ,CAACI,IAAD,CAAT,CAAH,GAAsB,IAAtB;AACH,KAFD;AAGH;;AACD,SAAOH,GAAP;AACH,CARM;AASP;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAII,uBAAuB,GAAG,UAAUC,IAAV,EAAgBC,OAAhB,EAAyB;AAC1D,MAAIC,KAAK,GAAGD,OAAO,CAACC,KAApB;AAAA,MAA2BC,WAAW,GAAGF,OAAO,CAACE,WAAjD;AAAA,MAA8DV,KAAK,GAAGQ,OAAO,CAACR,KAA9E;AAAA,MAAqFW,EAAE,GAAGH,OAAO,CAACI,aAAlG;AAAA,MAAiHA,aAAa,GAAGD,EAAE,KAAK,KAAK,CAAZ,GAAgB,OAAhB,GAA0BA,EAA3J;AAAA,MAA+JE,SAAS,GAAGL,OAAO,CAACK,SAAnL;AACA,MAAIZ,QAAQ,GAAGH,MAAM,CAACY,WAAD,CAArB;AACA,MAAII,QAAQ,GAAGf,WAAW,CAACC,KAAD,EAAQC,QAAR,CAA1B;;AACA,MAAIY,SAAS,KAAK,OAAlB,EAA2B;AACvB,WAAO,EAAP;AACH,GAFD,MAGK,IAAIA,SAAS,KAAK,QAAlB,EAA4B;AAC7B,QAAIE,iBAAiB,GAAGhB,WAAW,CAACU,KAAD,EAAQR,QAAR,CAAnC;AACA,WAAOD,KAAK,CAACgB,MAAN,CAAa,UAAUX,IAAV,EAAgB;AAAE,aAAO,CAACU,iBAAiB,CAACd,QAAQ,CAACI,IAAD,CAAT,CAAzB;AAA4C,KAA3E,CAAP;AACH,GAVyD,CAW1D;;;AACA,MAAIY,YAAY,GAAGR,KAAK,CAAC,CAAD,CAAxB;AACA,MAAIS,UAAU,GAAGjB,QAAQ,CAACgB,YAAD,CAAzB;AACA,MAAIE,aAAa,GAAGrB,MAAM,CAACc,aAAD,CAA1B;AACA,MAAIQ,KAAK,GAAGb,IAAI,CAACc,KAAL,EAAZ;AACA,MAAIC,OAAO,GAAG,EAAd;AACA,MAAIC,OAAJ;AACA,MAAIC,SAAJ;;AACA,SAAOJ,KAAK,CAACjB,MAAb,EAAqB;AACjB,QAAIsB,WAAW,GAAGL,KAAK,CAACM,GAAN,EAAlB;;AACA,QAAIR,UAAU,KAAKjB,QAAQ,CAACwB,WAAD,CAA3B,EAA0C;AACtCF,MAAAA,OAAO,GAAGD,OAAO,CAACpB,GAAR,CAAY,UAAUyB,WAAV,EAAuB;AAAE,eAAOA,WAAW,CAACtB,IAAnB;AAA0B,OAA/D,CAAV;AACAmB,MAAAA,SAAS,GAAGC,WAAZ;AACA;AACH,KAJD,MAKK;AACD,UAAIH,OAAO,IACPA,OAAO,CAACnB,MADR,IAEAmB,OAAO,CAACA,OAAO,CAACnB,MAAR,GAAiB,CAAlB,CAAP,CAA4ByB,cAA5B,KAA+CR,KAAK,CAACjB,MAFzD,EAEiE;AAC7DmB,QAAAA,OAAO,CAACI,GAAR;AACH;;AACD,UAAIG,QAAQ,GAAGV,aAAa,CAACM,WAAD,CAA5B;;AACA,UAAII,QAAQ,IAAIA,QAAQ,CAAC1B,MAAzB,EAAiC;AAC7BmB,QAAAA,OAAO,CAACQ,IAAR,CAAa;AAAEzB,UAAAA,IAAI,EAAEoB,WAAR;AAAqBG,UAAAA,cAAc,EAAER,KAAK,CAACjB;AAA3C,SAAb;AACAiB,QAAAA,KAAK,CAACU,IAAN,CAAWC,KAAX,CAAiBX,KAAjB,EAAwBS,QAAxB;AACH;AACJ;AACJ;;AACD,MAAIG,aAAa,GAAG,CAACb,aAAa,CAACK,SAAD,CAAb,IAA4B,EAA7B,EAAiCH,KAAjC,EAApB;AACA,MAAIY,QAAQ,GAAG,EAAf;;AACA,SAAOD,aAAa,CAAC7B,MAArB,EAA6B;AACzB,QAAIsB,WAAW,GAAGO,aAAa,CAACN,GAAd,EAAlB;AACAO,IAAAA,QAAQ,CAACH,IAAT,CAAcL,WAAd;AACA,QAAII,QAAQ,GAAGV,aAAa,CAACM,WAAD,CAA5B;;AACA,QAAII,QAAQ,IAAIA,QAAQ,CAAC1B,MAAzB,EAAiC;AAC7B6B,MAAAA,aAAa,CAACF,IAAd,CAAmBC,KAAnB,CAAyBC,aAAzB,EAAwCH,QAAxC;AACH;AACJ;;AACD,MAAIK,SAAS,GAAG,CAACpB,QAAQ,CAACI,UAAD,CAAzB;AACA,MAAIiB,QAAQ,GAAG,EAAf;;AACA,MAAID,SAAJ,EAAe;AACXC,IAAAA,QAAQ,CAACL,IAAT,CAAcC,KAAd,CAAoBI,QAApB,EAA8BnC,KAA9B;AACAmC,IAAAA,QAAQ,CAACL,IAAT,CAAcN,SAAd;AACAW,IAAAA,QAAQ,CAACL,IAAT,CAAcC,KAAd,CAAoBI,QAApB,EAA8BF,QAAQ,CAACjB,MAAT,CAAgB,UAAUX,IAAV,EAAgB;AAAE,aAAO,CAACS,QAAQ,CAACb,QAAQ,CAACI,IAAD,CAAT,CAAhB;AAAmC,KAArE,CAA9B;AACA,QAAI+B,gBAAgB,GAAGb,OAAO,CAACP,MAAR,CAAe,UAAUX,IAAV,EAAgB;AAAE,aAAO,CAACS,QAAQ,CAACb,QAAQ,CAACI,IAAD,CAAT,CAAhB;AAAmC,KAApE,CAAvB;AACA,QAAIgC,aAAa,GAAGtC,WAAW,CAACoC,QAAD,EAAWlC,QAAX,CAA/B;;AACA,SAAK,IAAIqC,CAAC,GAAGF,gBAAgB,CAACjC,MAAjB,GAA0B,CAAvC,EAA0CmC,CAAC,GAAG,CAAC,CAA/C,EAAkDA,CAAC,EAAnD,EAAuD;AACnD,UAAIC,SAAS,GAAGH,gBAAgB,CAACE,CAAD,CAAhC;AACA,UAAIT,QAAQ,GAAGV,aAAa,CAACoB,SAAD,CAA5B;AACA,UAAIC,qBAAqB,GAAGX,QAAQ,CAACb,MAAT,CAAgB,UAAUX,IAAV,EAAgB;AAAE,eAAOgC,aAAa,CAACpC,QAAQ,CAACI,IAAD,CAAT,CAApB;AAAuC,OAAzE,EAA2EF,MAAvG;;AACA,UAAIqC,qBAAqB,GAAGX,QAAQ,CAAC1B,MAArC,EAA6C;AACzC;AACH,OAFD,MAGK;AACDgC,QAAAA,QAAQ,CAACL,IAAT,CAAcS,SAAd;AACAF,QAAAA,aAAa,CAACpC,QAAQ,CAACsC,SAAD,CAAT,CAAb,GAAqC,IAArC;AACH;AACJ;AACJ,GAlBD,MAmBK;AACD,QAAIE,SAAS,GAAGxC,QAAQ,CAACuB,SAAD,CAAxB;AACA,QAAIkB,aAAa,GAAG3C,WAAW,CAACkC,QAAD,EAAWhC,QAAX,CAA/B;AACA,QAAI0C,YAAY,GAAG5C,WAAW,CAACwB,OAAD,EAAUtB,QAAV,CAA9B;AACAkC,IAAAA,QAAQ,CAACL,IAAT,CAAcC,KAAd,CAAoBI,QAApB,EAA+BnC,KAAK,CAC/BgB,MAD0B,CACnB,UAAUX,IAAV,EAAgB;AACxB,UAAIuC,MAAM,GAAG3C,QAAQ,CAACI,IAAD,CAArB;AACA,aAAO,CAACqC,aAAa,CAACE,MAAD,CAAd,IAA0BH,SAAS,KAAKG,MAAxC,IAAkD,CAACD,YAAY,CAACC,MAAD,CAAtE;AACH,KAJ8B,CAA/B;AAKH;;AACD,SAAOT,QAAP;AACH,CAjFM,C,CAkFP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["import { getter } from '@progress/kendo-react-common';\n/** @hidden */\nexport var getValueMap = function (value, idGetter) {\n    var map = {};\n    if (value && value.length) {\n        value.forEach(function (item) {\n            map[idGetter(item)] = true;\n        });\n    }\n    return map;\n};\n/**\n * Get MultiSelectTree new value from the component `onChange` event.\n *\n * @param {any[]} data\n * @param {object} options\n * @returns {any[]}\n */\nexport var getMultiSelectTreeValue = function (data, options) {\n    var items = options.items, dataItemKey = options.dataItemKey, value = options.value, _a = options.subItemsField, subItemsField = _a === void 0 ? 'items' : _a, operation = options.operation;\n    var idGetter = getter(dataItemKey);\n    var valueMap = getValueMap(value, idGetter);\n    if (operation === 'clear') {\n        return [];\n    }\n    else if (operation === 'delete') {\n        var deletedItemsMap_1 = getValueMap(items, idGetter);\n        return value.filter(function (item) { return !deletedItemsMap_1[idGetter(item)]; });\n    }\n    // operation === 'toggle'\n    var selectedItem = items[0];\n    var selectedId = idGetter(selectedItem);\n    var subItemGetter = getter(subItemsField);\n    var stack = data.slice();\n    var context = [];\n    var parents;\n    var foundItem;\n    while (stack.length) {\n        var currentItem = stack.pop();\n        if (selectedId === idGetter(currentItem)) {\n            parents = context.map(function (contextItem) { return contextItem.item; });\n            foundItem = currentItem;\n            break;\n        }\n        else {\n            if (context &&\n                context.length &&\n                context[context.length - 1].parentPosition === stack.length) {\n                context.pop();\n            }\n            var subItems = subItemGetter(currentItem);\n            if (subItems && subItems.length) {\n                context.push({ item: currentItem, parentPosition: stack.length });\n                stack.push.apply(stack, subItems);\n            }\n        }\n    }\n    var childrenStack = (subItemGetter(foundItem) || []).slice();\n    var children = [];\n    while (childrenStack.length) {\n        var currentItem = childrenStack.pop();\n        children.push(currentItem);\n        var subItems = subItemGetter(currentItem);\n        if (subItems && subItems.length) {\n            childrenStack.push.apply(childrenStack, subItems);\n        }\n    }\n    var isChecked = !valueMap[selectedId];\n    var newValue = [];\n    if (isChecked) {\n        newValue.push.apply(newValue, value);\n        newValue.push(foundItem);\n        newValue.push.apply(newValue, children.filter(function (item) { return !valueMap[idGetter(item)]; }));\n        var parentCandidates = parents.filter(function (item) { return !valueMap[idGetter(item)]; });\n        var newValueMap_1 = getValueMap(newValue, idGetter);\n        for (var i = parentCandidates.length - 1; i > -1; i--) {\n            var candidate = parentCandidates[i];\n            var subItems = subItemGetter(candidate);\n            var checkedChildrenLength = subItems.filter(function (item) { return newValueMap_1[idGetter(item)]; }).length;\n            if (checkedChildrenLength < subItems.length) {\n                break;\n            }\n            else {\n                newValue.push(candidate);\n                newValueMap_1[idGetter(candidate)] = true;\n            }\n        }\n    }\n    else {\n        var foundId_1 = idGetter(foundItem);\n        var childrenMap_1 = getValueMap(children, idGetter);\n        var parentsMap_1 = getValueMap(parents, idGetter);\n        newValue.push.apply(newValue, (value\n            .filter(function (item) {\n            var itemId = idGetter(item);\n            return !childrenMap_1[itemId] && foundId_1 !== itemId && !parentsMap_1[itemId];\n        })));\n    }\n    return newValue;\n};\n// /** @hidden */\n// const mapCheckAndIntermidiate = (\n//     data,\n//     options: {\n//         valueMap: {[dataItemKey: string]: boolean};\n//         callback?: (item: any) => any;\n//         idGetter: (item: any) => any;\n//         subItemGetter: (item: any) => any;\n//         subItemSetter: (item: any, value: any) => void;\n//         checkSetter: (item: any, value: any) => void;\n//         checkIndeterminateSetter: (item: any, value: any) => void;\n//     }\n// ) => {\n//     const {\n//         idGetter,\n//         subItemGetter,\n//         subItemSetter,\n//         checkSetter,\n//         checkIndeterminateSetter\n//     } = options;\n//     if (!data || !data.length) { return [data, false];}\n//     let hasChecked = false;\n//     const newData = [...data].map(dataItem => {\n//         const [children, hasCheckedChildren] = mapCheckAndIntermidiate(subItemGetter(dataItem), options);\n//         const isChecked = options.valueMap[idGetter(dataItem)];\n//         if (isChecked || hasCheckedChildren) {\n//             hasChecked = true;\n//         }\n//         const newItem = { ...dataItem };\n//         subItemSetter(newItem, children);\n//         checkSetter(newItem, isChecked);\n//         checkIndeterminateSetter(newItem, !isChecked && hasCheckedChildren);\n//         return options.callback ? options.callback(newItem) : newItem;\n//     });\n//     return [newData, hasChecked];\n// };\n// /**\n//  *\n//  * @param data\n//  * @param options\n//  * @returns\n//  */\n// /**\n//  * Creates a new array with the results of calling the provided callback function\n//  * on every element in the provided data tree. The new tree items have their `check` and `checkIndeterminate` fields set based on provided value.\n//  *\n//  * @param {any[]} tree - The data tree.\n//  * @param {object} options - The options used to map the tree items like check and checkIndeterminateField fields\n//  * @returns {any[]} - The new data tree.\n//  */\n// export const mapMultiSelectTreeData = (\n//     tree,\n//     options: {\n//         checkField?: string;\n//         checkIndeterminateField?: string;\n//         subItemsField?: string;\n//         dataItemKey: string;\n//         value: Array<any>;\n//         callback?: (item) => any;\n//     }\n// ) => {\n//     const {\n//         subItemsField = 'items',\n//         checkField = 'checkField',\n//         checkIndeterminateField = 'checkIndeterminateField',\n//         callback\n//     } = options;\n//     const idGetter = getter(options.dataItemKey);\n//     const [result] = mapCheckAndIntermidiate(\n//         tree,\n//         {\n//             callback,\n//             valueMap: getValueMap(options.value, idGetter),\n//             idGetter,\n//             subItemGetter: getter(subItemsField),\n//             subItemSetter: setter(subItemsField),\n//             checkSetter: setter(checkField),\n//             checkIndeterminateSetter: setter(checkIndeterminateField)\n//         }\n//     );\n//     return result;\n// };\n"]},"metadata":{},"sourceType":"module"}