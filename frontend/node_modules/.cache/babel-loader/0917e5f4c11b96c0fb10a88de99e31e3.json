{"ast":null,"code":"import { addItem, removeItem } from './utils/itemUtils';\nimport { getDecrementedItemIdAfterRemoval, getItemById } from './utils/itemIdUtils';\nimport { CHILDREN_FIELD } from './utils/consts';\n/**\n *  A helper function which moves a TreeView item in an immutable way.\n *\n * @param sourceItemHierarchicalIndex - The hierarchical index of the item that will be moved.\n * @param sourceData - The tree which contains the item that will be moved.\n * @param operation - The specific move operation.\n *\n * The available options are:\n *  * `before`&mdash;Indicates that the source item will become the previous sibling of the target item.\n *  * `after`&mdash;Indicates that the source item will become the next sibling of the target item.\n *  * `child`&mdash;Indicates that the source item will become a child of the target item.\n * @param targetItemHierarchicalIndex - The hierarchical index of the item next to which the source item will be moved.\n * @param targetData - The tree which contains the target item.\n * If the argument is skipped, then the move operation will be executed within the same tree.\n * Setting the `sourceData` and `targetData` arguments to the same tree is also supported.\n * @param childrenField - The field that points to the dataItem sub items. Defaults to `items`.\n * @returns - The updated copies of the `sourceData` and `targetData` input arguments.\n * If `targetData` is not passed, then only the updated copy of the `sourceData` will be returned.\n *\n * @example\n * ```jsx\n * class App extends React.Component {\n *     dragClue;\n *     state = { tree };\n *\n *     render() {\n *         return (\n *             <div>\n *                 <TreeView data={this.state.tree} draggable={true}\n *                     onItemDragOver={this.onItemDragOver} onItemDragEnd={this.onItemDragEnd} />\n *                 <TreeViewDragClue ref={dragClue => this.dragClue = dragClue} />\n *             </div>\n *         );\n *     }\n *\n *     onItemDragOver = (event) => {\n *         this.dragClue.show(event.pageY + 10, event.pageX, event.item.text, this.getClueClassName(event));\n *     }\n *     onItemDragEnd = (event) => {\n *         this.dragClue.hide();\n *         const eventAnalyzer = new TreeViewDragAnalyzer(event).init();\n *\n *         if (eventAnalyzer.isDropAllowed) {\n *             const updatedTree = moveTreeViewItem(\n *                 event.itemHierarchicalIndex,\n *                 this.state.tree,\n *                 eventAnalyzer.getDropOperation(),\n *                 eventAnalyzer.destinationMeta.itemHierarchicalIndex,\n *             );\n *\n *             this.setState({ tree: updatedTree });\n *         }\n *     }\n *     getClueClassName(event) {\n *         const eventAnalyzer = new TreeViewDragAnalyzer(event).init();\n *         const itemIndex = eventAnalyzer.destinationMeta.itemHierarchicalIndex;\n *\n *         if (eventAnalyzer.isDropAllowed) {\n *             switch (eventAnalyzer.getDropOperation()) {\n *                 case 'child':\n *                     return 'k-i-plus';\n *                 case 'before':\n *                     return itemIndex === '0' || itemIndex.endsWith(`${SEPARATOR}0`) ?\n *                         'k-i-insert-up' : 'k-i-insert-middle';\n *                 case 'after':\n *                     const siblings = getSiblings(itemIndex, this.state.tree);\n *                     const lastIndex = Number(itemIndex.split(SEPARATOR).pop());\n *\n *                     return lastIndex < siblings.length - 1 ? 'k-i-insert-middle' : 'k-i-insert-down';\n *                 default:\n *                     break;\n *             }\n *         }\n *\n *         return 'k-i-cancel';\n *     }\n * }\n *\n * function getSiblings(itemIndex, data) {\n *     let result = data;\n *\n *     const indices = itemIndex.split(SEPARATOR).map(index => Number(index));\n *     for (let i = 0; i < indices.length - 1; i++) {\n *         result = result[indices[i]].items;\n *     }\n *\n *     return result;\n * }\n *\n * const SEPARATOR = '_';\n * const tree = [{\n *     text: 'Furniture', expanded: true, items: [\n *         { text: 'Tables & Chairs', expanded: true },\n *         { text: 'Sofas', expanded: true },\n *         { text: 'Occasional Furniture', expanded: true }]\n * }, {\n *     text: 'Decor', expanded: true, items: [\n *         { text: 'Bed Linen', expanded: true },\n *         { text: 'Curtains & Blinds', expanded: true },\n *         { text: 'Carpets', expanded: true }]\n * }];\n *\n * ReactDOM.render(<App />, document.querySelector('my-app'));\n * ```\n */\n\nexport default function moveTreeViewItem(sourceItemHierarchicalIndex, sourceData, operation, targetItemHierarchicalIndex, targetData, childrenField) {\n  var subItemsField = childrenField || CHILDREN_FIELD;\n\n  if (!validateInput()) {\n    return prepareInputDataForReturn();\n  }\n\n  var sourceItem = getItemById(sourceItemHierarchicalIndex, sourceData, subItemsField);\n\n  if (!sourceItem) {\n    return prepareInputDataForReturn();\n  } // The source and the target tree are the same.\n\n\n  if (!targetData || targetData === sourceData) {\n    if (!validateNoCircularReference()) {\n      return prepareInputDataForReturn();\n    }\n\n    var updatedSourceData = removeItem(sourceItemHierarchicalIndex, subItemsField, sourceData);\n    var resultData = addItem(sourceItem, operation, subItemsField, getDecrementedItemIdAfterRemoval(sourceItemHierarchicalIndex, targetItemHierarchicalIndex), updatedSourceData); // A simpler output is explicitly returned when the source and the target tree are\n    // the same, that is, the targetData argument is skipped.\n\n    return targetData ? {\n      sourceData: resultData,\n      targetData: resultData\n    } : resultData;\n  } else {\n    var updatedSource = removeItem(sourceItemHierarchicalIndex, subItemsField, sourceData);\n    var updatedTarget = addItem(sourceItem, operation, subItemsField, targetItemHierarchicalIndex, targetData);\n    return {\n      sourceData: updatedSource,\n      targetData: updatedTarget\n    };\n  }\n\n  function prepareInputDataForReturn() {\n    return targetData ? {\n      sourceData: sourceData,\n      targetData: targetData\n    } : sourceData;\n  }\n\n  function validateNoCircularReference() {\n    return !(targetItemHierarchicalIndex + \"_\").startsWith(sourceItemHierarchicalIndex + \"_\");\n  }\n\n  function validateInput() {\n    if (!sourceData || !sourceData.length || !sourceItemHierarchicalIndex || !targetItemHierarchicalIndex) {\n      return false;\n    }\n\n    if (targetData && !targetData.length) {\n      // Dropping over an empty tree is not supported.\n      return false;\n    } // Validate that the target item exists.\n\n\n    var data = !targetData || targetData === sourceData ? sourceData : targetData;\n\n    if (!getItemById(targetItemHierarchicalIndex, data, subItemsField)) {\n      return false;\n    }\n\n    return true;\n  }\n}","map":{"version":3,"sources":["/Users/leecavazos/Desktop/COSC4353/COSC4353-1/frontend/node_modules/@progress/kendo-react-treeview/dist/es/moveTreeViewItem.js"],"names":["addItem","removeItem","getDecrementedItemIdAfterRemoval","getItemById","CHILDREN_FIELD","moveTreeViewItem","sourceItemHierarchicalIndex","sourceData","operation","targetItemHierarchicalIndex","targetData","childrenField","subItemsField","validateInput","prepareInputDataForReturn","sourceItem","validateNoCircularReference","updatedSourceData","resultData","updatedSource","updatedTarget","startsWith","length","data"],"mappings":"AAAA,SAASA,OAAT,EAAkBC,UAAlB,QAAoC,mBAApC;AACA,SAASC,gCAAT,EAA2CC,WAA3C,QAA8D,qBAA9D;AACA,SAASC,cAAT,QAA+B,gBAA/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe,SAASC,gBAAT,CAA0BC,2BAA1B,EAAuDC,UAAvD,EAAmEC,SAAnE,EAA8EC,2BAA9E,EAA2GC,UAA3G,EAAuHC,aAAvH,EAAsI;AACjJ,MAAIC,aAAa,GAAGD,aAAa,IAAIP,cAArC;;AACA,MAAI,CAACS,aAAa,EAAlB,EAAsB;AAClB,WAAOC,yBAAyB,EAAhC;AACH;;AACD,MAAIC,UAAU,GAAGZ,WAAW,CAACG,2BAAD,EAA8BC,UAA9B,EAA0CK,aAA1C,CAA5B;;AACA,MAAI,CAACG,UAAL,EAAiB;AACb,WAAOD,yBAAyB,EAAhC;AACH,GARgJ,CASjJ;;;AACA,MAAI,CAACJ,UAAD,IAAeA,UAAU,KAAKH,UAAlC,EAA8C;AAC1C,QAAI,CAACS,2BAA2B,EAAhC,EAAoC;AAChC,aAAOF,yBAAyB,EAAhC;AACH;;AACD,QAAIG,iBAAiB,GAAGhB,UAAU,CAACK,2BAAD,EAA8BM,aAA9B,EAA6CL,UAA7C,CAAlC;AACA,QAAIW,UAAU,GAAGlB,OAAO,CAACe,UAAD,EAAaP,SAAb,EAAwBI,aAAxB,EAAuCV,gCAAgC,CAACI,2BAAD,EAA8BG,2BAA9B,CAAvE,EAAmIQ,iBAAnI,CAAxB,CAL0C,CAM1C;AACA;;AACA,WAAOP,UAAU,GAAG;AAAEH,MAAAA,UAAU,EAAEW,UAAd;AAA0BR,MAAAA,UAAU,EAAEQ;AAAtC,KAAH,GAAwDA,UAAzE;AACH,GATD,MAUK;AACD,QAAIC,aAAa,GAAGlB,UAAU,CAACK,2BAAD,EAA8BM,aAA9B,EAA6CL,UAA7C,CAA9B;AACA,QAAIa,aAAa,GAAGpB,OAAO,CAACe,UAAD,EAAaP,SAAb,EAAwBI,aAAxB,EAAuCH,2BAAvC,EAAoEC,UAApE,CAA3B;AACA,WAAO;AAAEH,MAAAA,UAAU,EAAEY,aAAd;AAA6BT,MAAAA,UAAU,EAAEU;AAAzC,KAAP;AACH;;AACD,WAASN,yBAAT,GAAqC;AACjC,WAAOJ,UAAU,GAAG;AAAEH,MAAAA,UAAU,EAAEA,UAAd;AAA0BG,MAAAA,UAAU,EAAEA;AAAtC,KAAH,GAAwDH,UAAzE;AACH;;AACD,WAASS,2BAAT,GAAuC;AACnC,WAAO,CAAC,CAACP,2BAA2B,GAAG,GAA/B,EAAoCY,UAApC,CAA+Cf,2BAA2B,GAAG,GAA7E,CAAR;AACH;;AACD,WAASO,aAAT,GAAyB;AACrB,QAAI,CAACN,UAAD,IAAe,CAACA,UAAU,CAACe,MAA3B,IACA,CAAChB,2BADD,IACgC,CAACG,2BADrC,EACkE;AAC9D,aAAO,KAAP;AACH;;AACD,QAAIC,UAAU,IAAI,CAACA,UAAU,CAACY,MAA9B,EAAsC;AAClC;AACA,aAAO,KAAP;AACH,KARoB,CASrB;;;AACA,QAAIC,IAAI,GAAG,CAACb,UAAD,IAAeA,UAAU,KAAKH,UAA9B,GAA2CA,UAA3C,GAAwDG,UAAnE;;AACA,QAAI,CAACP,WAAW,CAACM,2BAAD,EAA8Bc,IAA9B,EAAoCX,aAApC,CAAhB,EAAoE;AAChE,aAAO,KAAP;AACH;;AACD,WAAO,IAAP;AACH;AACJ","sourcesContent":["import { addItem, removeItem } from './utils/itemUtils';\nimport { getDecrementedItemIdAfterRemoval, getItemById } from './utils/itemIdUtils';\nimport { CHILDREN_FIELD } from './utils/consts';\n/**\n *  A helper function which moves a TreeView item in an immutable way.\n *\n * @param sourceItemHierarchicalIndex - The hierarchical index of the item that will be moved.\n * @param sourceData - The tree which contains the item that will be moved.\n * @param operation - The specific move operation.\n *\n * The available options are:\n *  * `before`&mdash;Indicates that the source item will become the previous sibling of the target item.\n *  * `after`&mdash;Indicates that the source item will become the next sibling of the target item.\n *  * `child`&mdash;Indicates that the source item will become a child of the target item.\n * @param targetItemHierarchicalIndex - The hierarchical index of the item next to which the source item will be moved.\n * @param targetData - The tree which contains the target item.\n * If the argument is skipped, then the move operation will be executed within the same tree.\n * Setting the `sourceData` and `targetData` arguments to the same tree is also supported.\n * @param childrenField - The field that points to the dataItem sub items. Defaults to `items`.\n * @returns - The updated copies of the `sourceData` and `targetData` input arguments.\n * If `targetData` is not passed, then only the updated copy of the `sourceData` will be returned.\n *\n * @example\n * ```jsx\n * class App extends React.Component {\n *     dragClue;\n *     state = { tree };\n *\n *     render() {\n *         return (\n *             <div>\n *                 <TreeView data={this.state.tree} draggable={true}\n *                     onItemDragOver={this.onItemDragOver} onItemDragEnd={this.onItemDragEnd} />\n *                 <TreeViewDragClue ref={dragClue => this.dragClue = dragClue} />\n *             </div>\n *         );\n *     }\n *\n *     onItemDragOver = (event) => {\n *         this.dragClue.show(event.pageY + 10, event.pageX, event.item.text, this.getClueClassName(event));\n *     }\n *     onItemDragEnd = (event) => {\n *         this.dragClue.hide();\n *         const eventAnalyzer = new TreeViewDragAnalyzer(event).init();\n *\n *         if (eventAnalyzer.isDropAllowed) {\n *             const updatedTree = moveTreeViewItem(\n *                 event.itemHierarchicalIndex,\n *                 this.state.tree,\n *                 eventAnalyzer.getDropOperation(),\n *                 eventAnalyzer.destinationMeta.itemHierarchicalIndex,\n *             );\n *\n *             this.setState({ tree: updatedTree });\n *         }\n *     }\n *     getClueClassName(event) {\n *         const eventAnalyzer = new TreeViewDragAnalyzer(event).init();\n *         const itemIndex = eventAnalyzer.destinationMeta.itemHierarchicalIndex;\n *\n *         if (eventAnalyzer.isDropAllowed) {\n *             switch (eventAnalyzer.getDropOperation()) {\n *                 case 'child':\n *                     return 'k-i-plus';\n *                 case 'before':\n *                     return itemIndex === '0' || itemIndex.endsWith(`${SEPARATOR}0`) ?\n *                         'k-i-insert-up' : 'k-i-insert-middle';\n *                 case 'after':\n *                     const siblings = getSiblings(itemIndex, this.state.tree);\n *                     const lastIndex = Number(itemIndex.split(SEPARATOR).pop());\n *\n *                     return lastIndex < siblings.length - 1 ? 'k-i-insert-middle' : 'k-i-insert-down';\n *                 default:\n *                     break;\n *             }\n *         }\n *\n *         return 'k-i-cancel';\n *     }\n * }\n *\n * function getSiblings(itemIndex, data) {\n *     let result = data;\n *\n *     const indices = itemIndex.split(SEPARATOR).map(index => Number(index));\n *     for (let i = 0; i < indices.length - 1; i++) {\n *         result = result[indices[i]].items;\n *     }\n *\n *     return result;\n * }\n *\n * const SEPARATOR = '_';\n * const tree = [{\n *     text: 'Furniture', expanded: true, items: [\n *         { text: 'Tables & Chairs', expanded: true },\n *         { text: 'Sofas', expanded: true },\n *         { text: 'Occasional Furniture', expanded: true }]\n * }, {\n *     text: 'Decor', expanded: true, items: [\n *         { text: 'Bed Linen', expanded: true },\n *         { text: 'Curtains & Blinds', expanded: true },\n *         { text: 'Carpets', expanded: true }]\n * }];\n *\n * ReactDOM.render(<App />, document.querySelector('my-app'));\n * ```\n */\nexport default function moveTreeViewItem(sourceItemHierarchicalIndex, sourceData, operation, targetItemHierarchicalIndex, targetData, childrenField) {\n    var subItemsField = childrenField || CHILDREN_FIELD;\n    if (!validateInput()) {\n        return prepareInputDataForReturn();\n    }\n    var sourceItem = getItemById(sourceItemHierarchicalIndex, sourceData, subItemsField);\n    if (!sourceItem) {\n        return prepareInputDataForReturn();\n    }\n    // The source and the target tree are the same.\n    if (!targetData || targetData === sourceData) {\n        if (!validateNoCircularReference()) {\n            return prepareInputDataForReturn();\n        }\n        var updatedSourceData = removeItem(sourceItemHierarchicalIndex, subItemsField, sourceData);\n        var resultData = addItem(sourceItem, operation, subItemsField, getDecrementedItemIdAfterRemoval(sourceItemHierarchicalIndex, targetItemHierarchicalIndex), updatedSourceData);\n        // A simpler output is explicitly returned when the source and the target tree are\n        // the same, that is, the targetData argument is skipped.\n        return targetData ? { sourceData: resultData, targetData: resultData } : resultData;\n    }\n    else {\n        var updatedSource = removeItem(sourceItemHierarchicalIndex, subItemsField, sourceData);\n        var updatedTarget = addItem(sourceItem, operation, subItemsField, targetItemHierarchicalIndex, targetData);\n        return { sourceData: updatedSource, targetData: updatedTarget };\n    }\n    function prepareInputDataForReturn() {\n        return targetData ? { sourceData: sourceData, targetData: targetData } : sourceData;\n    }\n    function validateNoCircularReference() {\n        return !(targetItemHierarchicalIndex + \"_\").startsWith(sourceItemHierarchicalIndex + \"_\");\n    }\n    function validateInput() {\n        if (!sourceData || !sourceData.length ||\n            !sourceItemHierarchicalIndex || !targetItemHierarchicalIndex) {\n            return false;\n        }\n        if (targetData && !targetData.length) {\n            // Dropping over an empty tree is not supported.\n            return false;\n        }\n        // Validate that the target item exists.\n        var data = !targetData || targetData === sourceData ? sourceData : targetData;\n        if (!getItemById(targetItemHierarchicalIndex, data, subItemsField)) {\n            return false;\n        }\n        return true;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}