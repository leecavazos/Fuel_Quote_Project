{"ast":null,"code":"import { __spreadArray, __read } from 'tslib';\nimport * as React from 'react';\nimport { useContext, useRef, cloneElement, Children, isValidElement } from 'react';\nimport { useForceUpdate } from '../../utils/use-force-update.js';\nimport { PresenceChild } from './PresenceChild.js';\nimport { SharedLayoutContext, isSharedLayout } from '../../context/SharedLayoutContext.js';\n\nfunction getChildKey(child) {\n  return child.key || \"\";\n}\n\nfunction updateChildLookup(children, allChildren) {\n  var seenChildren = process.env.NODE_ENV !== \"production\" ? new Set() : null;\n  children.forEach(function (child) {\n    var key = getChildKey(child);\n\n    if (process.env.NODE_ENV !== \"production\" && seenChildren) {\n      if (seenChildren.has(key)) {\n        console.warn(\"Children of AnimatePresence require unique keys. \\\"\" + key + \"\\\" is a duplicate.\");\n      }\n\n      seenChildren.add(key);\n    }\n\n    allChildren.set(key, child);\n  });\n}\n\nfunction onlyElements(children) {\n  var filtered = []; // We use forEach here instead of map as map mutates the component key by preprending `.$`\n\n  Children.forEach(children, function (child) {\n    if (isValidElement(child)) filtered.push(child);\n  });\n  return filtered;\n}\n/**\r\n * `AnimatePresence` enables the animation of components that have been removed from the tree.\r\n *\r\n * When adding/removing more than a single child, every child **must** be given a unique `key` prop.\r\n *\r\n * @library\r\n *\r\n * Any `Frame` components that have an `exit` property defined will animate out when removed from\r\n * the tree.\r\n *\r\n * ```jsx\r\n * import { Frame, AnimatePresence } from 'framer'\r\n *\r\n * // As items are added and removed from `items`\r\n * export function Items({ items }) {\r\n *   return (\r\n *     <AnimatePresence>\r\n *       {items.map(item => (\r\n *         <Frame\r\n *           key={item.id}\r\n *           initial={{ opacity: 0 }}\r\n *           animate={{ opacity: 1 }}\r\n *           exit={{ opacity: 0 }}\r\n *         />\r\n *       ))}\r\n *     </AnimatePresence>\r\n *   )\r\n * }\r\n * ```\r\n *\r\n * You can sequence exit animations throughout a tree using variants.\r\n *\r\n * @motion\r\n *\r\n * Any `motion` components that have an `exit` property defined will animate out when removed from\r\n * the tree.\r\n *\r\n * ```jsx\r\n * import { motion, AnimatePresence } from 'framer-motion'\r\n *\r\n * export const Items = ({ items }) => (\r\n *   <AnimatePresence>\r\n *     {items.map(item => (\r\n *       <motion.div\r\n *         key={item.id}\r\n *         initial={{ opacity: 0 }}\r\n *         animate={{ opacity: 1 }}\r\n *         exit={{ opacity: 0 }}\r\n *       />\r\n *     ))}\r\n *   </AnimatePresence>\r\n * )\r\n * ```\r\n *\r\n * You can sequence exit animations throughout a tree using variants.\r\n *\r\n * If a child contains multiple `motion` components with `exit` props, it will only unmount the child\r\n * once all `motion` components have finished animating out. Likewise, any components using\r\n * `usePresence` all need to call `safeToRemove`.\r\n *\r\n * @public\r\n */\n\n\nvar AnimatePresence = function (_a) {\n  var children = _a.children,\n      custom = _a.custom,\n      _b = _a.initial,\n      initial = _b === void 0 ? true : _b,\n      onExitComplete = _a.onExitComplete,\n      exitBeforeEnter = _a.exitBeforeEnter,\n      _c = _a.presenceAffectsLayout,\n      presenceAffectsLayout = _c === void 0 ? true : _c; // We want to force a re-render once all exiting animations have finished. We\n  // either use a local forceRender function, or one from a parent context if it exists.\n\n  var forceRender = useForceUpdate();\n  var layoutContext = useContext(SharedLayoutContext);\n\n  if (isSharedLayout(layoutContext)) {\n    forceRender = layoutContext.forceUpdate;\n  }\n\n  var isInitialRender = useRef(true); // Filter out any children that aren't ReactElements. We can only track ReactElements with a props.key\n\n  var filteredChildren = onlyElements(children); // Keep a living record of the children we're actually rendering so we\n  // can diff to figure out which are entering and exiting\n\n  var presentChildren = useRef(filteredChildren); // A lookup table to quickly reference components by key\n\n  var allChildren = useRef(new Map()).current; // A living record of all currently exiting components.\n\n  var exiting = useRef(new Set()).current;\n  updateChildLookup(filteredChildren, allChildren); // If this is the initial component render, just deal with logic surrounding whether\n  // we play onMount animations or not.\n\n  if (isInitialRender.current) {\n    isInitialRender.current = false;\n    return React.createElement(React.Fragment, null, filteredChildren.map(function (child) {\n      return React.createElement(PresenceChild, {\n        key: getChildKey(child),\n        isPresent: true,\n        initial: initial ? undefined : false,\n        presenceAffectsLayout: presenceAffectsLayout\n      }, child);\n    }));\n  } // If this is a subsequent render, deal with entering and exiting children\n\n\n  var childrenToRender = __spreadArray([], __read(filteredChildren)); // Diff the keys of the currently-present and target children to update our\n  // exiting list.\n\n\n  var presentKeys = presentChildren.current.map(getChildKey);\n  var targetKeys = filteredChildren.map(getChildKey); // Diff the present children with our target children and mark those that are exiting\n\n  var numPresent = presentKeys.length;\n\n  for (var i = 0; i < numPresent; i++) {\n    var key = presentKeys[i];\n\n    if (targetKeys.indexOf(key) === -1) {\n      exiting.add(key);\n    } else {\n      // In case this key has re-entered, remove from the exiting list\n      exiting.delete(key);\n    }\n  } // If we currently have exiting children, and we're deferring rendering incoming children\n  // until after all current children have exiting, empty the childrenToRender array\n\n\n  if (exitBeforeEnter && exiting.size) {\n    childrenToRender = [];\n  } // Loop through all currently exiting components and clone them to overwrite `animate`\n  // with any `exit` prop they might have defined.\n\n\n  exiting.forEach(function (key) {\n    // If this component is actually entering again, early return\n    if (targetKeys.indexOf(key) !== -1) return;\n    var child = allChildren.get(key);\n    if (!child) return;\n    var insertionIndex = presentKeys.indexOf(key);\n\n    var onExit = function () {\n      allChildren.delete(key);\n      exiting.delete(key); // Remove this child from the present children\n\n      var removeIndex = presentChildren.current.findIndex(function (presentChild) {\n        return presentChild.key === key;\n      });\n      presentChildren.current.splice(removeIndex, 1); // Defer re-rendering until all exiting children have indeed left\n\n      if (!exiting.size) {\n        presentChildren.current = filteredChildren;\n        forceRender();\n        onExitComplete && onExitComplete();\n      }\n    };\n\n    childrenToRender.splice(insertionIndex, 0, React.createElement(PresenceChild, {\n      key: getChildKey(child),\n      isPresent: false,\n      onExitComplete: onExit,\n      custom: custom,\n      presenceAffectsLayout: presenceAffectsLayout\n    }, child));\n  }); // Add `MotionContext` even to children that don't need it to ensure we're rendering\n  // the same tree between renders\n\n  childrenToRender = childrenToRender.map(function (child) {\n    var key = child.key;\n    return exiting.has(key) ? child : React.createElement(PresenceChild, {\n      key: getChildKey(child),\n      isPresent: true,\n      presenceAffectsLayout: presenceAffectsLayout\n    }, child);\n  });\n  presentChildren.current = childrenToRender;\n\n  if (process.env.NODE_ENV !== \"production\" && exitBeforeEnter && childrenToRender.length > 1) {\n    console.warn(\"You're attempting to animate multiple children within AnimatePresence, but its exitBeforeEnter prop is set to true. This will lead to odd visual behaviour.\");\n  }\n\n  return React.createElement(React.Fragment, null, exiting.size ? childrenToRender : childrenToRender.map(function (child) {\n    return cloneElement(child);\n  }));\n};\n\nexport { AnimatePresence };","map":{"version":3,"sources":["C:/Users/Lizthebett/Desktop/COSC4353/frontend/node_modules/framer-motion/dist/es/components/AnimatePresence/index.js"],"names":["__spreadArray","__read","React","useContext","useRef","cloneElement","Children","isValidElement","useForceUpdate","PresenceChild","SharedLayoutContext","isSharedLayout","getChildKey","child","key","updateChildLookup","children","allChildren","seenChildren","process","env","NODE_ENV","Set","forEach","has","console","warn","add","set","onlyElements","filtered","push","AnimatePresence","_a","custom","_b","initial","onExitComplete","exitBeforeEnter","_c","presenceAffectsLayout","forceRender","layoutContext","forceUpdate","isInitialRender","filteredChildren","presentChildren","Map","current","exiting","createElement","Fragment","map","isPresent","undefined","childrenToRender","presentKeys","targetKeys","numPresent","length","i","indexOf","delete","size","get","insertionIndex","onExit","removeIndex","findIndex","presentChild","splice"],"mappings":"AAAA,SAASA,aAAT,EAAwBC,MAAxB,QAAsC,OAAtC;AACA,OAAO,KAAKC,KAAZ,MAAuB,OAAvB;AACA,SAASC,UAAT,EAAqBC,MAArB,EAA6BC,YAA7B,EAA2CC,QAA3C,EAAqDC,cAArD,QAA2E,OAA3E;AACA,SAASC,cAAT,QAA+B,iCAA/B;AACA,SAASC,aAAT,QAA8B,oBAA9B;AACA,SAASC,mBAAT,EAA8BC,cAA9B,QAAoD,sCAApD;;AAEA,SAASC,WAAT,CAAqBC,KAArB,EAA4B;AACxB,SAAOA,KAAK,CAACC,GAAN,IAAa,EAApB;AACH;;AACD,SAASC,iBAAT,CAA2BC,QAA3B,EAAqCC,WAArC,EAAkD;AAC9C,MAAIC,YAAY,GAAGC,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAAzB,GAAwC,IAAIC,GAAJ,EAAxC,GAAoD,IAAvE;AACAN,EAAAA,QAAQ,CAACO,OAAT,CAAiB,UAAUV,KAAV,EAAiB;AAC9B,QAAIC,GAAG,GAAGF,WAAW,CAACC,KAAD,CAArB;;AACA,QAAIM,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAAzB,IAAyCH,YAA7C,EAA2D;AACvD,UAAIA,YAAY,CAACM,GAAb,CAAiBV,GAAjB,CAAJ,EAA2B;AACvBW,QAAAA,OAAO,CAACC,IAAR,CAAa,wDAAwDZ,GAAxD,GAA8D,oBAA3E;AACH;;AACDI,MAAAA,YAAY,CAACS,GAAb,CAAiBb,GAAjB;AACH;;AACDG,IAAAA,WAAW,CAACW,GAAZ,CAAgBd,GAAhB,EAAqBD,KAArB;AACH,GATD;AAUH;;AACD,SAASgB,YAAT,CAAsBb,QAAtB,EAAgC;AAC5B,MAAIc,QAAQ,GAAG,EAAf,CAD4B,CAE5B;;AACAxB,EAAAA,QAAQ,CAACiB,OAAT,CAAiBP,QAAjB,EAA2B,UAAUH,KAAV,EAAiB;AACxC,QAAIN,cAAc,CAACM,KAAD,CAAlB,EACIiB,QAAQ,CAACC,IAAT,CAAclB,KAAd;AACP,GAHD;AAIA,SAAOiB,QAAP;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAIE,eAAe,GAAG,UAAUC,EAAV,EAAc;AAChC,MAAIjB,QAAQ,GAAGiB,EAAE,CAACjB,QAAlB;AAAA,MAA4BkB,MAAM,GAAGD,EAAE,CAACC,MAAxC;AAAA,MAAgDC,EAAE,GAAGF,EAAE,CAACG,OAAxD;AAAA,MAAiEA,OAAO,GAAGD,EAAE,KAAK,KAAK,CAAZ,GAAgB,IAAhB,GAAuBA,EAAlG;AAAA,MAAsGE,cAAc,GAAGJ,EAAE,CAACI,cAA1H;AAAA,MAA0IC,eAAe,GAAGL,EAAE,CAACK,eAA/J;AAAA,MAAgLC,EAAE,GAAGN,EAAE,CAACO,qBAAxL;AAAA,MAA+MA,qBAAqB,GAAGD,EAAE,KAAK,KAAK,CAAZ,GAAgB,IAAhB,GAAuBA,EAA9P,CADgC,CAEhC;AACA;;AACA,MAAIE,WAAW,GAAGjC,cAAc,EAAhC;AACA,MAAIkC,aAAa,GAAGvC,UAAU,CAACO,mBAAD,CAA9B;;AACA,MAAIC,cAAc,CAAC+B,aAAD,CAAlB,EAAmC;AAC/BD,IAAAA,WAAW,GAAGC,aAAa,CAACC,WAA5B;AACH;;AACD,MAAIC,eAAe,GAAGxC,MAAM,CAAC,IAAD,CAA5B,CATgC,CAUhC;;AACA,MAAIyC,gBAAgB,GAAGhB,YAAY,CAACb,QAAD,CAAnC,CAXgC,CAYhC;AACA;;AACA,MAAI8B,eAAe,GAAG1C,MAAM,CAACyC,gBAAD,CAA5B,CAdgC,CAehC;;AACA,MAAI5B,WAAW,GAAGb,MAAM,CAAC,IAAI2C,GAAJ,EAAD,CAAN,CACbC,OADL,CAhBgC,CAkBhC;;AACA,MAAIC,OAAO,GAAG7C,MAAM,CAAC,IAAIkB,GAAJ,EAAD,CAAN,CAAkB0B,OAAhC;AACAjC,EAAAA,iBAAiB,CAAC8B,gBAAD,EAAmB5B,WAAnB,CAAjB,CApBgC,CAqBhC;AACA;;AACA,MAAI2B,eAAe,CAACI,OAApB,EAA6B;AACzBJ,IAAAA,eAAe,CAACI,OAAhB,GAA0B,KAA1B;AACA,WAAQ9C,KAAK,CAACgD,aAAN,CAAoBhD,KAAK,CAACiD,QAA1B,EAAoC,IAApC,EAA0CN,gBAAgB,CAACO,GAAjB,CAAqB,UAAUvC,KAAV,EAAiB;AAAE,aAAQX,KAAK,CAACgD,aAAN,CAAoBzC,aAApB,EAAmC;AAAEK,QAAAA,GAAG,EAAEF,WAAW,CAACC,KAAD,CAAlB;AAA2BwC,QAAAA,SAAS,EAAE,IAAtC;AAA4CjB,QAAAA,OAAO,EAAEA,OAAO,GAAGkB,SAAH,GAAe,KAA3E;AAAkFd,QAAAA,qBAAqB,EAAEA;AAAzG,OAAnC,EAAqK3B,KAArK,CAAR;AAAuL,KAA/N,CAA1C,CAAR;AACH,GA1B+B,CA2BhC;;;AACA,MAAI0C,gBAAgB,GAAGvD,aAAa,CAAC,EAAD,EAAKC,MAAM,CAAC4C,gBAAD,CAAX,CAApC,CA5BgC,CA6BhC;AACA;;;AACA,MAAIW,WAAW,GAAGV,eAAe,CAACE,OAAhB,CAAwBI,GAAxB,CAA4BxC,WAA5B,CAAlB;AACA,MAAI6C,UAAU,GAAGZ,gBAAgB,CAACO,GAAjB,CAAqBxC,WAArB,CAAjB,CAhCgC,CAiChC;;AACA,MAAI8C,UAAU,GAAGF,WAAW,CAACG,MAA7B;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,UAApB,EAAgCE,CAAC,EAAjC,EAAqC;AACjC,QAAI9C,GAAG,GAAG0C,WAAW,CAACI,CAAD,CAArB;;AACA,QAAIH,UAAU,CAACI,OAAX,CAAmB/C,GAAnB,MAA4B,CAAC,CAAjC,EAAoC;AAChCmC,MAAAA,OAAO,CAACtB,GAAR,CAAYb,GAAZ;AACH,KAFD,MAGK;AACD;AACAmC,MAAAA,OAAO,CAACa,MAAR,CAAehD,GAAf;AACH;AACJ,GA5C+B,CA6ChC;AACA;;;AACA,MAAIwB,eAAe,IAAIW,OAAO,CAACc,IAA/B,EAAqC;AACjCR,IAAAA,gBAAgB,GAAG,EAAnB;AACH,GAjD+B,CAkDhC;AACA;;;AACAN,EAAAA,OAAO,CAAC1B,OAAR,CAAgB,UAAUT,GAAV,EAAe;AAC3B;AACA,QAAI2C,UAAU,CAACI,OAAX,CAAmB/C,GAAnB,MAA4B,CAAC,CAAjC,EACI;AACJ,QAAID,KAAK,GAAGI,WAAW,CAAC+C,GAAZ,CAAgBlD,GAAhB,CAAZ;AACA,QAAI,CAACD,KAAL,EACI;AACJ,QAAIoD,cAAc,GAAGT,WAAW,CAACK,OAAZ,CAAoB/C,GAApB,CAArB;;AACA,QAAIoD,MAAM,GAAG,YAAY;AACrBjD,MAAAA,WAAW,CAAC6C,MAAZ,CAAmBhD,GAAnB;AACAmC,MAAAA,OAAO,CAACa,MAAR,CAAehD,GAAf,EAFqB,CAGrB;;AACA,UAAIqD,WAAW,GAAGrB,eAAe,CAACE,OAAhB,CAAwBoB,SAAxB,CAAkC,UAAUC,YAAV,EAAwB;AAAE,eAAOA,YAAY,CAACvD,GAAb,KAAqBA,GAA5B;AAAkC,OAA9F,CAAlB;AACAgC,MAAAA,eAAe,CAACE,OAAhB,CAAwBsB,MAAxB,CAA+BH,WAA/B,EAA4C,CAA5C,EALqB,CAMrB;;AACA,UAAI,CAAClB,OAAO,CAACc,IAAb,EAAmB;AACfjB,QAAAA,eAAe,CAACE,OAAhB,GAA0BH,gBAA1B;AACAJ,QAAAA,WAAW;AACXJ,QAAAA,cAAc,IAAIA,cAAc,EAAhC;AACH;AACJ,KAZD;;AAaAkB,IAAAA,gBAAgB,CAACe,MAAjB,CAAwBL,cAAxB,EAAwC,CAAxC,EAA2C/D,KAAK,CAACgD,aAAN,CAAoBzC,aAApB,EAAmC;AAAEK,MAAAA,GAAG,EAAEF,WAAW,CAACC,KAAD,CAAlB;AAA2BwC,MAAAA,SAAS,EAAE,KAAtC;AAA6ChB,MAAAA,cAAc,EAAE6B,MAA7D;AAAqEhC,MAAAA,MAAM,EAAEA,MAA7E;AAAqFM,MAAAA,qBAAqB,EAAEA;AAA5G,KAAnC,EAAwK3B,KAAxK,CAA3C;AACH,GAtBD,EApDgC,CA2EhC;AACA;;AACA0C,EAAAA,gBAAgB,GAAGA,gBAAgB,CAACH,GAAjB,CAAqB,UAAUvC,KAAV,EAAiB;AACrD,QAAIC,GAAG,GAAGD,KAAK,CAACC,GAAhB;AACA,WAAOmC,OAAO,CAACzB,GAAR,CAAYV,GAAZ,IAAoBD,KAApB,GAA8BX,KAAK,CAACgD,aAAN,CAAoBzC,aAApB,EAAmC;AAAEK,MAAAA,GAAG,EAAEF,WAAW,CAACC,KAAD,CAAlB;AAA2BwC,MAAAA,SAAS,EAAE,IAAtC;AAA4Cb,MAAAA,qBAAqB,EAAEA;AAAnE,KAAnC,EAA+H3B,KAA/H,CAArC;AACH,GAHkB,CAAnB;AAIAiC,EAAAA,eAAe,CAACE,OAAhB,GAA0BO,gBAA1B;;AACA,MAAIpC,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAAzB,IACAiB,eADA,IAEAiB,gBAAgB,CAACI,MAAjB,GAA0B,CAF9B,EAEiC;AAC7BlC,IAAAA,OAAO,CAACC,IAAR,CAAa,6JAAb;AACH;;AACD,SAAQxB,KAAK,CAACgD,aAAN,CAAoBhD,KAAK,CAACiD,QAA1B,EAAoC,IAApC,EAA0CF,OAAO,CAACc,IAAR,GAC5CR,gBAD4C,GAE5CA,gBAAgB,CAACH,GAAjB,CAAqB,UAAUvC,KAAV,EAAiB;AAAE,WAAOR,YAAY,CAACQ,KAAD,CAAnB;AAA6B,GAArE,CAFE,CAAR;AAGH,CA1FD;;AA4FA,SAASmB,eAAT","sourcesContent":["import { __spreadArray, __read } from 'tslib';\r\nimport * as React from 'react';\r\nimport { useContext, useRef, cloneElement, Children, isValidElement } from 'react';\r\nimport { useForceUpdate } from '../../utils/use-force-update.js';\r\nimport { PresenceChild } from './PresenceChild.js';\r\nimport { SharedLayoutContext, isSharedLayout } from '../../context/SharedLayoutContext.js';\r\n\r\nfunction getChildKey(child) {\r\n    return child.key || \"\";\r\n}\r\nfunction updateChildLookup(children, allChildren) {\r\n    var seenChildren = process.env.NODE_ENV !== \"production\" ? new Set() : null;\r\n    children.forEach(function (child) {\r\n        var key = getChildKey(child);\r\n        if (process.env.NODE_ENV !== \"production\" && seenChildren) {\r\n            if (seenChildren.has(key)) {\r\n                console.warn(\"Children of AnimatePresence require unique keys. \\\"\" + key + \"\\\" is a duplicate.\");\r\n            }\r\n            seenChildren.add(key);\r\n        }\r\n        allChildren.set(key, child);\r\n    });\r\n}\r\nfunction onlyElements(children) {\r\n    var filtered = [];\r\n    // We use forEach here instead of map as map mutates the component key by preprending `.$`\r\n    Children.forEach(children, function (child) {\r\n        if (isValidElement(child))\r\n            filtered.push(child);\r\n    });\r\n    return filtered;\r\n}\r\n/**\r\n * `AnimatePresence` enables the animation of components that have been removed from the tree.\r\n *\r\n * When adding/removing more than a single child, every child **must** be given a unique `key` prop.\r\n *\r\n * @library\r\n *\r\n * Any `Frame` components that have an `exit` property defined will animate out when removed from\r\n * the tree.\r\n *\r\n * ```jsx\r\n * import { Frame, AnimatePresence } from 'framer'\r\n *\r\n * // As items are added and removed from `items`\r\n * export function Items({ items }) {\r\n *   return (\r\n *     <AnimatePresence>\r\n *       {items.map(item => (\r\n *         <Frame\r\n *           key={item.id}\r\n *           initial={{ opacity: 0 }}\r\n *           animate={{ opacity: 1 }}\r\n *           exit={{ opacity: 0 }}\r\n *         />\r\n *       ))}\r\n *     </AnimatePresence>\r\n *   )\r\n * }\r\n * ```\r\n *\r\n * You can sequence exit animations throughout a tree using variants.\r\n *\r\n * @motion\r\n *\r\n * Any `motion` components that have an `exit` property defined will animate out when removed from\r\n * the tree.\r\n *\r\n * ```jsx\r\n * import { motion, AnimatePresence } from 'framer-motion'\r\n *\r\n * export const Items = ({ items }) => (\r\n *   <AnimatePresence>\r\n *     {items.map(item => (\r\n *       <motion.div\r\n *         key={item.id}\r\n *         initial={{ opacity: 0 }}\r\n *         animate={{ opacity: 1 }}\r\n *         exit={{ opacity: 0 }}\r\n *       />\r\n *     ))}\r\n *   </AnimatePresence>\r\n * )\r\n * ```\r\n *\r\n * You can sequence exit animations throughout a tree using variants.\r\n *\r\n * If a child contains multiple `motion` components with `exit` props, it will only unmount the child\r\n * once all `motion` components have finished animating out. Likewise, any components using\r\n * `usePresence` all need to call `safeToRemove`.\r\n *\r\n * @public\r\n */\r\nvar AnimatePresence = function (_a) {\r\n    var children = _a.children, custom = _a.custom, _b = _a.initial, initial = _b === void 0 ? true : _b, onExitComplete = _a.onExitComplete, exitBeforeEnter = _a.exitBeforeEnter, _c = _a.presenceAffectsLayout, presenceAffectsLayout = _c === void 0 ? true : _c;\r\n    // We want to force a re-render once all exiting animations have finished. We\r\n    // either use a local forceRender function, or one from a parent context if it exists.\r\n    var forceRender = useForceUpdate();\r\n    var layoutContext = useContext(SharedLayoutContext);\r\n    if (isSharedLayout(layoutContext)) {\r\n        forceRender = layoutContext.forceUpdate;\r\n    }\r\n    var isInitialRender = useRef(true);\r\n    // Filter out any children that aren't ReactElements. We can only track ReactElements with a props.key\r\n    var filteredChildren = onlyElements(children);\r\n    // Keep a living record of the children we're actually rendering so we\r\n    // can diff to figure out which are entering and exiting\r\n    var presentChildren = useRef(filteredChildren);\r\n    // A lookup table to quickly reference components by key\r\n    var allChildren = useRef(new Map())\r\n        .current;\r\n    // A living record of all currently exiting components.\r\n    var exiting = useRef(new Set()).current;\r\n    updateChildLookup(filteredChildren, allChildren);\r\n    // If this is the initial component render, just deal with logic surrounding whether\r\n    // we play onMount animations or not.\r\n    if (isInitialRender.current) {\r\n        isInitialRender.current = false;\r\n        return (React.createElement(React.Fragment, null, filteredChildren.map(function (child) { return (React.createElement(PresenceChild, { key: getChildKey(child), isPresent: true, initial: initial ? undefined : false, presenceAffectsLayout: presenceAffectsLayout }, child)); })));\r\n    }\r\n    // If this is a subsequent render, deal with entering and exiting children\r\n    var childrenToRender = __spreadArray([], __read(filteredChildren));\r\n    // Diff the keys of the currently-present and target children to update our\r\n    // exiting list.\r\n    var presentKeys = presentChildren.current.map(getChildKey);\r\n    var targetKeys = filteredChildren.map(getChildKey);\r\n    // Diff the present children with our target children and mark those that are exiting\r\n    var numPresent = presentKeys.length;\r\n    for (var i = 0; i < numPresent; i++) {\r\n        var key = presentKeys[i];\r\n        if (targetKeys.indexOf(key) === -1) {\r\n            exiting.add(key);\r\n        }\r\n        else {\r\n            // In case this key has re-entered, remove from the exiting list\r\n            exiting.delete(key);\r\n        }\r\n    }\r\n    // If we currently have exiting children, and we're deferring rendering incoming children\r\n    // until after all current children have exiting, empty the childrenToRender array\r\n    if (exitBeforeEnter && exiting.size) {\r\n        childrenToRender = [];\r\n    }\r\n    // Loop through all currently exiting components and clone them to overwrite `animate`\r\n    // with any `exit` prop they might have defined.\r\n    exiting.forEach(function (key) {\r\n        // If this component is actually entering again, early return\r\n        if (targetKeys.indexOf(key) !== -1)\r\n            return;\r\n        var child = allChildren.get(key);\r\n        if (!child)\r\n            return;\r\n        var insertionIndex = presentKeys.indexOf(key);\r\n        var onExit = function () {\r\n            allChildren.delete(key);\r\n            exiting.delete(key);\r\n            // Remove this child from the present children\r\n            var removeIndex = presentChildren.current.findIndex(function (presentChild) { return presentChild.key === key; });\r\n            presentChildren.current.splice(removeIndex, 1);\r\n            // Defer re-rendering until all exiting children have indeed left\r\n            if (!exiting.size) {\r\n                presentChildren.current = filteredChildren;\r\n                forceRender();\r\n                onExitComplete && onExitComplete();\r\n            }\r\n        };\r\n        childrenToRender.splice(insertionIndex, 0, React.createElement(PresenceChild, { key: getChildKey(child), isPresent: false, onExitComplete: onExit, custom: custom, presenceAffectsLayout: presenceAffectsLayout }, child));\r\n    });\r\n    // Add `MotionContext` even to children that don't need it to ensure we're rendering\r\n    // the same tree between renders\r\n    childrenToRender = childrenToRender.map(function (child) {\r\n        var key = child.key;\r\n        return exiting.has(key) ? (child) : (React.createElement(PresenceChild, { key: getChildKey(child), isPresent: true, presenceAffectsLayout: presenceAffectsLayout }, child));\r\n    });\r\n    presentChildren.current = childrenToRender;\r\n    if (process.env.NODE_ENV !== \"production\" &&\r\n        exitBeforeEnter &&\r\n        childrenToRender.length > 1) {\r\n        console.warn(\"You're attempting to animate multiple children within AnimatePresence, but its exitBeforeEnter prop is set to true. This will lead to odd visual behaviour.\");\r\n    }\r\n    return (React.createElement(React.Fragment, null, exiting.size\r\n        ? childrenToRender\r\n        : childrenToRender.map(function (child) { return cloneElement(child); })));\r\n};\r\n\r\nexport { AnimatePresence };\r\n"]},"metadata":{},"sourceType":"module"}